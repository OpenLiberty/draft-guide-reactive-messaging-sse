//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: reactive-messaging-sse
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-04-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to push Server-Sent Events from a reactive messaging application to a front-end application
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['microprofile-reactive-messaging', 'microprofile-reactive-messaging-acknowledgement', 'reactive-service-testing', 'containerize']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Streaming messages from a MicroProfile Reactive Messaging microservice using Server-Sent Events (SSE)
:page-seo-description: A getting started tutorial with examples on how to stream messages as Server-Sent Events (SSE) from a MicroProfile Reactive Messaging Java application to a front-end client.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Streaming messages to a client using Server-Sent Events

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to stream messages from a MicroProfile Reactive Messaging service to a
front-end client by using Server-Sent Events (SSE).

// =================================================================================================
//  What you'll learn
// =================================================================================================

== What you'll learn

You will learn how to stream messages from a MicroProfile Reactive Messaging service to a
front-end client by using Server-Sent Events (SSE).

MicroProfile Reactive Messaging provides an easy way for Java services to
asynchronously send, receive, and process messages that are received as
continuous streams of events. SSE provides a convenient way to
stream the data in these events to a browser client while maintaining the
asynchronicity of the communication and flow of data.

=== What is SSE?

Server-Sent Events is an API that allows
clients to subscribe to a stream of events that is pushed from a server. First, the
client makes a connection with the server over HTTP. The server continuously pushes events to the client as
long as the connection persists. SSE differs from traditional HTTP requests, which
use one request for one response. SSE also differs from Web Sockets in that SSE is unidirectional from
the server to the client, and Web Sockets allow for bidirectional communication.

This guide consists of a `frontend` application and three instances of the `system`
service. The `system` services periodically publish messages containing their
hostname and current system load. The `frontend` application consists of a front-end
JavaScript client and a `bff` (backend for frontend) service. The `bff` service
receives the messages from the `system` services and pushes the contents as events
to the front-end client that consumes them and displays a table that contains
each system's hostname and its periodically updating load. The following
diagram depicts the application that is used in this guide:

image::SSE_Diagram.png[JWT frontend and system services, align="center"]

To learn more about the reactive Java services that are used in this guide, check out the https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating
reactive Java microservices^] guide.


// =================================================================================================
// Prerequisites
// =================================================================================================

== Additional prerequisites

You will build and run the messaging services and the front-end application in Docker containers. You can learn more about containerizing microservices with Docker in the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Install Docker and start your Docker environment by following https://docs.docker.com/engine/installation[the instructions from Docker^].


// =================================================================================================
// Getting started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]


// =================================================================================================
// Setting up SSE in the bff service
// =================================================================================================

== Setting up SSE in the bff service

// File 0
BFFResource.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/frontend/src/main/java/io/openliberty/guides/bff/BFFResource.java[]
----

// File 1
microprofile-config.properties
[source, text, linenums, role='code_column hide_tags=copyright']
----
include::finish/frontend/src/main/resources/META-INF/microprofile-config.properties[]
----

In this section, you will create a REST API for SSE in the `bff` service
which will allow clients to subscribe to events. Additionally, the service will
read the messages from the incoming stream and push the contents to the
subscribers via SSE.

Navigate to the `start` directory to begin.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the BFFResource class.#
`frontend/src/main/java/io/openliberty/guides/bff/BFFResource.java`
----

=== Creating the SSE API endpoint

The [hotspot=subscribeToSystems file=0]`subscribeToSystem()` method allows
clients to subscribe to events via an HTTP `GET` request to the `/bff/sse/`
endpoint. The [hotspot=sseMimeType
file=0]`@Produces(MediaType.SERVER_SENT_EVENTS)` annotation sets the `Content-Type` in the
response header to `text/event-stream`. This content type indicates that client requests that are made
to this endpoint are to receive Server-Sent Events. Additionally, the method
parameters take in an [hotspot=sseEventSinkParam file=0]`SseEventSink` and an
[hotspot=sseParam file=0]`Sse` which are injected by using the `@Context`
annotation. First, the method checks if the [hotspot=sse file=0]`sse` and
[hotspot=broadcaster file=0]`broadcaster` instance variables are assigned.
If these variables aren't assigned, the
[hotspot=sse file=0]`sse` variable is obtained from the [hotspot=sseParam
file=0]`@Context` injection and the [hotspot=broadcaster file=0]`broadcaster` variable
is obtained by using the [hotspot=newBroadcaster file=0]`Sse.newBroadcaster()`
method. Then, the [hotspot=registerSink file=0]`register()` method is called to
register the [hotspot=sseEventSinkParam file=0]`SseEventSink` to the
[hotspot=broadcaster file=0]`SseBroadcaster` to subscribe to events.

For more information about these interfaces, see the Javadocs for
https://openliberty.io/docs/ref/javaee/8/#class=javax/ws/rs/sse/OutboundSseEvent.html&package=allclasses-frame.html[OutboundSseEvent^]
and
https://openliberty.io/docs/ref/javaee/8/#class=javax/ws/rs/sse/OutboundSseEvent.Builder.html&package=allclasses-frame.html[OutboundSseEvent.Builder^].

=== Reading from the reactive messaging channel

The [hotspot=getSystemLoadMessage file=0]`getSystemLoadMessage()` method
receives the message that contains the hostname and the average system load. The
[hotspot=systemLoad file=0]`@Incoming("systemLoad")` annotation indicates that
the method retrieves the message by connecting to the `systemLoad` channel in
Kafka, which you configure in the next section.

Each time a message is received, the [hotspot=getSystemLoadMessage
file=0]`getSystemLoadMessage()` method is called, and the hostname and system
load contained in that message are broadcasted in an event to all subscribers.

=== Broadcasting events

Broadcasting events is handled in the [hotspot=broadcastData
file=0]`broadcastData()` method. First, it checks whether the
[hotspot=broadcaster file=0]`broadcaster` value is [hotspot=notNull file=0]`null`.
There must be at least one subscriber or there's no
client to send the event to. If the `broadcaster` value is specified, the
`OutboundSseEvent` interface is created by using the [hotspot=newEventBuilder
file=0]`Sse.newEventBuilder()` method, where the [hotspot=name file=0]`name` of the
event, the [hotspot=data file=0]`data` it contains, and the
[hotspot=mediaType file=0]`media type` are set. The `OutboundSseEvent` interface is then
broadcasted, or sent to all registered sinks, by invoking the
[hotspot=broadcastEvent file=0]`SseBroadcaster.broadcast()` method.

// =================================================================================================
// Configuring the Kafka connector for the bff service
// =================================================================================================

== Configuring the Kafka connector for the bff service

// File 0
microprofile-config.properties
[source, text, linenums, role='code_column hide_tags=copyright']
----
include::finish/frontend/src/main/resources/META-INF/microprofile-config.properties[]
----

A complete `system` service is provided for you in the `start/system`
directory. The `system` service is the producer of the messages that are
published to the Kafka messaging system. The periodically
published messages contain the system's hostname and a calculation of the
average system load (its CPU usage) for the last minute.

Configure the Kafka connector in the `bff` service to receive the messages from the `system` service.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the microprofile-config.properties file.#
`frontend/src/main/resources/META-INF/microprofile-config.properties`
----

The `bff` service uses an incoming connector to receive messages through
the [hotspot=systemLoadChannel file=0]`systemLoad` channel. The messages are
then published by the `system` service to the [hotspot=systemLoadTopic
file=0]`system.load` property in the Kafka message broker. The
[hotspot=keyDeserializer file=0]`key.deserializer` and
[hotspot=valueDeserializer file=0]`value.deserializer` properties define how to
deserialize the messages. The [hotspot=groupId file=0]`group.id` property
defines a unique name for the consumer group. All of these properties are
required by the https://kafka.apache.org/documentation/#consumerconfigs[Apache
Kafka Consumer Configs^] documentation.


// =================================================================================================
// Configuring the front-end client to subscribe to and consume events
// =================================================================================================

== Configuring the front-end client to subscribe to and consume events

// File 0
index.js
[source, javascript, linenums, role='code_column hide_tags=copyright']
----
include::finish/frontend/src/main/webapp/js/index.js[]
----

In this section, you will configure the front-end client to subscribe to events
and display their contents in a table in the UI.

The front-end UI is a table where each row contains the hostname and load of one of the three system services.
The HTML and styling for the UI is provided for you but you must populate the table with
information that is received from the Server-Sent Events.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the index.js file.#
`frontend/src/main/webapp/js/index.js`
----

=== Subscribing to SSE

The [hotspot=initSSE file=0]`initSSE()` method is called when the page first
loads. This subscribes the client to the SSE by creating a new instance of
[hotspot=eventSource file=0]`EventSource` interface and specifying the `/bff/sse`
endpoint in the parameter. The [hotspot=eventSource file=0]`EventSource` interface
makes a `GET` request to this endpoint with a request header of `Accept:
text/event-stream` to connect to the server.

=== Consuming the SSE

The [hotspot=eventListener file=0]`EventSource.addEventListener()` method is
called to add an event listener. This event listener listens for events with
the name of [hotspot=systemLoad file=0]`systemLoad`. The
[hotspot=systemLoadHandler file=0]`systemLoadHandler()` function is set as the
handler function, and each time an event is received, this function is called.
The [hotspot=systemLoadHandler file=0]`systemLoadHandler()` function will take the event
object and parse the event's data property from a JSON string into a JavaScript
object. The contents of this object are used to
update the table with the system hostname and load. If a system is already present in the table, the load is
updated, otherwise a new row is added for the system.

// =================================================================================================
// Building and running the application
// =================================================================================================

== Building and running the application

To build the application, navigate to the `start` directory and run the following Maven `install` and `package` goals from the command line:

[role='command']
```
mvn -pl models install
mvn package
```

Run the following command to download or update to the latest
`openliberty/open-liberty:kernel-java8-openj9-ubi` Docker image:

[role='command']
```
docker pull openliberty/open-liberty:kernel-java8-openj9-ubi
```

Run the following commands to containerize the `frontend` application and `system` service:

[role='command']
```
docker build -t frontend:1.0-SNAPSHOT frontend/.
docker build -t system:1.0-SNAPSHOT system/.
```

Next, use the following `startContainers.sh` script to start the application in Docker containers:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--
This script creates a network for the containers to communicate with each other. It
also creates containers for Kafka, Zookeeper, the `frontend` application, and three
instances of the `system` service.

Once your application is up and running, open your browser and check out your
service by visiting http://localhost:9080[http://localhost:9080]. The
application might take some time to get ready. The latest version of most
modern web browsers supports Server-Sent Events. The exception is
Internet Explorer, which does not support SSE.

When you visit the URL, look for a table similar to the following example:

image::system_table.png[System table, align="center"]

The table contains three rows, one for each of the running system
containers. If you can see the loads updating, you know that your `bff` service
is successfully receiving messages and broadcasting them as SSE to the front-end client
for display.

// =================================================================================================
// Tearing down the environment
// =================================================================================================

== Tearing down the environment

Run the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--
// =================================================================================================
// Great work! You're done!
// =================================================================================================

== Great work! You're done!

You developed an application that subscribes to Server-Sent Events by using MicroProfile Reactive Messaging, Open Liberty, and Kafka.

== Related Links

Learn more about MicroProfile.

https://microprofile.io/[See the MicroProfile specs^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_microprofile_reactive_messaging[View the MicroProfile Reactive Messaging Specification^]

https://openliberty.io/docs/ref/javaee/8/#package=javax/ws/rs/sse/package-frame.html&class=javax/ws/rs/sse/package-summary.html[View the JAX-RS Server-Sent Events API^]

https://html.spec.whatwg.org/multipage/server-sent-events.html[View the Server-Sent Events HTML Specification^]

include::{common-includes}/attribution.adoc[subs="attributes"]
